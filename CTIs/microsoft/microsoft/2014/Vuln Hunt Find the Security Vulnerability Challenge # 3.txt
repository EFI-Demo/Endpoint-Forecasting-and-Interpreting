
		Posted by Brandon Caldwell, Security Manager, Trustworthy Computing & Ali Pezeshk, Security Engineer, Trustworthy Computing
This particular type of vulnerability is used to attack data-driven applications found across the web.  It has been around for over a decade and is one of the top threats today.  Do you know what it is?  Here’s another hint: it executes malicious queries in situations where user supplied inputs are not properly sanitized and validated before submitting to a database.
If you guessed SQL Injection, give yourself a point.  Despite the security community’s continuous battles against the seemingly endless threat of SQL Injection, this particular type of attack still finds its way into software vulnerabilities.  If it clearly represents a significant risk to software and the data it handles, why is it still such a prevalent attack method?
Below is an example of a somewhat sneaky SQL Injection. Three points are possible for solving this one, plus an extra bonus point.
 SQL PROCEDURE DEFINITION:

C# TO EXECUTE QUEURY:

Give yourself one point if you can spot the vulnerability. As you can see, SQL Injection is not always as easy to address as we would like to think. Here we have a SQL Stored Procedure that would be used to pull items off of a SQL Service Server Broker queue, and some .Net code to call the procedure. This example is already going in the right direction by ensuring that actions against the database are executed through a Parameterized Stored Procedure and not using a query dynamically generated in code (See SDL guidance for SQL injection). Give yourself another two points if you noticed both the safe practices there, and if you spotted the weakness. The weaknesses in this example lies in how the parameter is leveraged for the query and how the parameter is passed in from the code.
First, in the SQL, the parameter is simply concatenated onto a query string – a big no-no. Because of this concatenation, the parameter is not bound to the statement as a variable, effectively allowing dynamic SQL to be written into the procedure. This procedure was created in order to allow any queue to be queried, providing for more flexibility. This flexibility is of course the source of the vulnerability, and increases the attack surface. An effective mitigation in this case would be to limit the allowed size of @parameter, making the following change for example:

This simple change would significantly limit the opportunity of an attacker to inject malicious SQL into the statement, and puts only minor limitations on developers when naming the queues. And a bonus point if you recognized this improvement on your own!
Second, while not explicit in this example, there’s no evidence that the string passed into the DoGetMessage function has been validated. In this case, the attacker would be allowed to call the .Net method, or the procedure directly, and pass in any value into this query. An example malicious string could be:

Or the slightly more nefarious:

This example scenario borrows code from a real world project, wherein this vulnerability was discovered as part of a security code review and fixed before the code was shipped to the customer (a Stored Procedure for every queue was created instead). It’s difficult to predict for this specific example the actual risk and the chance the vulnerability would be discovered, however, it does highlight that careful review is important, and that review cannot just be a shallow inspection of high risk code and that code must be considered from the mindset of an attacker – just using a parameterized stored procedure does not guarantee security.
The Microsoft SDL Threat Modeling Tool (free download) can be helpful in reviewing the implementation of the aforementioned rules during product design and in identifying potential SQL injection threats you will need to mitigate when you start writing code. As said above, this was discovered as part of a code review, initiated from concern when evaluating the Threat Model – a real world example of the benefits Threat Modeling can provide.
Give yourself a bonus point if you’ve ever used threat modeling for a security review.
SQL Injection is still a top threat, and as such, it is important to be sure and dedicate adequate resources on how and when your software accesses data. This code sample gives an example of why SQL Injection persists – it can be subtle and hidden inside otherwise secure code.
For more information on SQL Injection, I encourage you to check out the following resources:

SDL Process Guidance, Implementation Phase
MSDN Patterns and Practices: How To: Protect From SQL Injection in ASP.NET
SQL Injection topic in SQL Books Online
19 Deadly Sins of Software Security by Howard, LeBlanc, and Viega
Writing Secure Code (Second Edition) by Howard and LeBlanc

 
	