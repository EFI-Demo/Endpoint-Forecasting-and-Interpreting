
		Whether it’s a riddle, puzzle, or detective mystery novel, most of us like to solve a good brain teaser. As security and program experts, these types of conundrums keep us on our toes. During the next few weeks, I’ll share some of my favorites, and see if you can find the security vulnerability. For this first one, let’s take a look at authenticated encryption. Two points are possible for solving this stumper, plus an extra bonus point.  Question:
 
First off, let’s give one point to the programmer, who realized that many encryption algorithms do not in themselves provide any integrity protection.
Encryption prevents an eavesdropper “Eve” from reading the message that Alice sends to Bob, but contrary to popular belief, it does not prevent Eve from intercepting and tampering with that message. (There are notable exceptions such as Galois/Counter Mode (GCM) and Counter with CBC-MAC (CCM) encryption modes, but for the purposes of this question we will assume that a non-authenticated encryption mode such as Cipher-block Chaining (CBC) was used.)
We also give a point to the programmer for using an encrypt-then-MAC design.
Alternative approaches (MAC-then-encrypt and encrypt-and-MAC) are extremely dangerous and have led to several serious security vulnerabilities: read Moxie Marlinspike’s blog post on the “Cryptographic Doom Principle” if you’d like to delve deeper. Give yourself a point if you realized that an encrypt-then-MAC approach is not a security bug.
However, although the programmer correctly validates the HMAC before decrypting, he does so a byte at a time and returns false as soon as he gets a mismatched byte. This means that a tampered HMAC value will fail slightly faster if the first byte is wrong than if the first byte is right. A persistent attacker may be able to exploit this timing difference to craft a valid HMAC for a tampered message. Give yourself a point if you found this timing attack vulnerability in the for-loop.
Finally, although it’s not a security “bug” per se, give yourself a bonus point if you noted that this code uses hardcoded cryptographic algorithms and is therefore not cryptographically agile.
All crypto weakens over time, and while HMAC-SHA256 is considered a strong algorithm now, that may change in the future (and perhaps suddenly). You should plan for this eventuality now and avoid hardcoding cryptographic algorithms into your code: see “Cryptographic Agility” for more details.
While finding a solution can be entertaining, it can also be serious business when it comes to security. For us, the goal is to provide even greater protection for data across all the great Microsoft services you use and depend on every day.
Next week, we’ll take a look at regular expressions.
	